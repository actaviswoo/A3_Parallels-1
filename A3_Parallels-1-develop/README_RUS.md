# Parallels

Реализация проекта Parallels.


## Contents

1. [Chapter I](#chapter-i) \
   1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
   2.1. [Многопоточность](#многопоточность) \
   2.2. [Мьютексы](#мьютексы) \
   2.3. [Метод конвейерного параллелизма](#метод-конвейерного-параллелизма)
3. [Chapter III](#chapter-iii) \
   3.1. [Part 1](#part-1-муравьиный-алгоритм)  \
   3.2. [Part 2](#part-2-решение-слау)  \
   3.3. [Part 3](#part-3-алгоритм-винограда)


## Chapter I

![Parallels](misc/images/Parallels.JPG)

Чак сел за стол с таким грохотом, что кофе чуть не выплеснулся из чашки.

`-` Ты не поверишь, что я только что узнал от чувака из ИБ, — начал он, выглядывая официанта. Это кафе было местом, которое они вдвоем облюбовали еще во времена студенчества. Оно было немноголюдным, с вкусным кофе и десертами, а самое главное — всегда тихим и спокойным. В самый раз, чтобы заниматься своими делами — работать, или учиться, что сейчас Ева и делала. Ее давно привлекала тема многопоточности и распараллеливания алгоритмов. А тут наконец нашлось время позаниматься и изучить ее как следует.

`-` Короче, наши «гении» наверху умудрились потерять какой-то опасный сверхразумный искусственный интеллект, — Чак перешел на шепот. — Уж не знаю, для какого пылесоса-убийцы они его там готовили, но все, похоже, в панике. Говорят, Боб сам не свой.

`-` Звучит серьезно, — оторвалась от своих задачек Ева. — Я тоже слышала краем уха нечто подобное, но Боб не выглядел таким уж напуганным. Да и как можно потерять искусственный интеллект? Не выпал же он из кармана.

`-` Черт его знает. А вдруг сбежал сам? Так или иначе, но выглядит это все очень грязно. Ты видела наши финансовые отчеты? А я работаю с ними. И там все совсем не радужно, чтобы еще и вкладываться в каких-то инновационных роботов. Говорю тебе, они подпольно создают Терминатора.

`-` Да брось ты, — задумавшись произнесла Ева.

`-` Ну, вот увидишь, — отвлеченно ответил Чак. — Так, что это ты заказала? М-м, пахнет вкусно...

## Introduction

В данном проекте тебе предстоит ознакомиться с основными подходами к параллелизму, а также реализовать некоторые алгоритмы с его применением.


## Chapter II

### Многопоточность

**Синхронная программная модель** — это программная модель, в рамках которой каждому потоку назначается набор задач. Все задачи в рамках потока выполняются последовательно друг за другом, когда завершено выполнение одной задачи, появляется возможность заняться другой. В этой модели невозможно останавливать выполнение задачи, чтобы в промежутке выполнить другую задачу.

Частным случаем синхронной модели является *однопоточность*. Если имеется несколько задач, которые надлежит выполнить, и текущая система предоставляет один поток, который может работать со всеми задачами, то он берет поочередно одну за другой и процесс выглядит так:

![singlethreaded](misc/images/singlethreaded.png)

Здесь видно, что имеется поток и четыре задачи, которые необходимо выполнить.
Поток начинает выполнять поочередно одну за одной и выполняет их в итоге все.

В случаях, когда порядок, в котором задачи выполняются, не влияет на результат работы программы, может быть применена *многопоточность*.

Многопоточность является другим случаем синхронной модели – в этом сценарии, используются много потоков, которые могут брать задачи и приступать к работе с ними, т.е. у нас есть пулы потоков и множество задач. \
Итак, многопоточность может работать вот так:

![multithreaded](misc/images/multithreaded.png)

Здесь можно видеть, что у нас есть четыре потока и столько же задач для выполнения, и каждый поток начинает работать с ними.
Это идеальный сценарий, но в обычных условиях используется большее количество задач чем количество доступных потоков, таким образом освободившийся поток получает другое задание. \
Нежелательно каждый раз создавать новые потоки, потому что для этого требуется использование дополнительных системных ресурсов, таких как процессорное время и память. Поэтому изначальное количество потоков должно быть заранее заданным.

### Мьютексы

При написании многопоточных приложений почти всегда требуется работать с общими данными, одновременное изменение которых может привести к очень неприятным последствиям.
Для блокировки общих данных от одновременного доступа необходимо использовать *объекты синхронизации*.

**Мьютекс** (англ. mutex) представляет собой взаимно исключающий синхронизирующий объект.
Это означает, что он может быть получен потоком только по очереди.
Мьютекс предназначен для тех ситуаций, в которых общий ресурс может быть одновременно использован только в одном из потоков.
Допустим, что системный журнал совместно используется в нескольких процессах, но только в одном из них данные могут записываться в файл этого журнала в любой момент времени.
Для синхронизации процессов в данной ситуации идеально подходит мьютекс.

Для описания мьютекса требуется всего один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное состояние, а все остальные значения соответствуют блокированному состоянию.
Значение мьютекса устанавливается двумя процедурами: захвата и освобождения.
1. Если поток собирается войти в критическую область, он вызывает процедуру захвата.
2. Если мьютекс не заблокирован, запрос выполняется и вызывающий поток может попасть в критическую область.
3. Если мьютекс закрыт, то поток пытающийся войти в критическую секцию блокируется.
4. Если поток собирается выйти из критической области, он, соответственно, вызывает процедуру освобождения.

Принципы работы с мьютексами отличаются в Windows и Linux, но в общем случае можно выделить следующие шаги:
- создание/описание,
- открытие/инициализация,
- попытка захвата и ожидание,
- освобождение.

### Метод конвейерного параллелизма

Классическим способом применения многопоточности, в случае когда необходимо решить одну и ту же задачу для некоторого количества *N* наборов исходных данных, является запуск всего алгоритма в одном потоке.
При таком подходе каждым потоком алгоритм выполняется для *N/(число_потоков)* наборов исходных данных.

**Конвейеризация** (или конвейерная обработка) в общем случае основана на разделении подлежащего исполнению алгоритма на более мелкие части, называемые ступенями, и выделении для каждой из них отдельного потока.
Так обработку любого набора данных можно разделить на несколько этапов, организовав передачу данных от одного этапа к следующему.
Производительность при этом возрастает благодаря тому, что на различных ступенях (в разных потоках) конвейера одновременно обрабатываются разные наборы данных.

Пример организации работы конвейера:

![pipeline](misc/images/conveyor.png)

В качестве конкретного примера можно привести алгоритм поиска наибольшего числа в строке.
На вход подается массив строк, для каждой из которых нужно выполнить поиск.
В первом потоке будет выполняться разбиение строки на слова, во втором приведение слов к числовому типу данных, в третьем поиск наибольшего среди чисел.
И тогда процесс работы будет выглядеть так:
1. В первом потоке обрабатывается первая строка из массива. Остальные строки ожидают своей очереди.
2. Массив слов, полученный после обработки первой строки поступает на обработку во второй поток. Так как первой поток освободился, в него на обработку поступает вторая строка.
3. Далее переход между вторым и третьим потоками происходит так же, как и между первым и вторым.
4. В случае, если вторая строка обработалась в первом потоке быстрее, чем первая строка во втором потоке, вторая строка поступает в очередь ожидающих освобождения второго потока. Тем временем, так как первой поток освободился, в него на обработку поступает третья строка.


## Chapter III

## Part 1. Муравьиный алгоритм

Реализуй муравьиный алгоритм для решения задачи коммивояжера из прошлого задания *A2_SimpleNavigator* с применением параллельных вычислений и без них:
- Программа должна быть разработана на языке C++ стандарта C++17.
- Код программы должен находиться в папке src.
- При написании кода придерживайся Google Style.
- Не используй устаревшие и выведенные из употребления конструкции языка и библиотечные функции.
- Предусмотри Makefile для сборки программы (с целями all, clean, ant).
- У программы должен быть предусмотрен консольный интерфейс.
- Пользователем задается матрица для задачи коммивояжера.
- Пользователем задается кол-во выполнений *N*.
- Выведи на экран результаты работы каждого из алгоритмов для указанной матрицы.
- Измерь время, которое потребуется для выполнения *N* раз муравьиного алгоритма с применением параллелизма для заданной пользователем матрицы.
- Измерь время, которое потребуется для выполнения *N* раз обычного муравьиного алгоритма для заданной пользователем матрицы.
- На экран выведи полученное в обоих случаях время.
- Для блокировки доступа к данным при параллельной реализации используй мьютексы.

## Part 2. Решение СЛАУ

Реализуй обычный и параллельный алгоритмы решения СЛАУ методом Гаусса:
- Программа должна быть разработана на языке C++ стандарта C++17.
- Код программы должен находиться в папке src.
- При написании кода придерживайся Google Style.
- Не используй устаревшие и выведенные из употребления конструкции языка и библиотечные функции.
- Добавь в существующий Makefile цель «gauss» для сборки программы.
- У программы должен быть предусмотрен консольный интерфейс.
- Пользователем задается матрица, описывающая СЛАУ.
- Пользователем задается кол-во выполнений *N*.
- Выведи на экран результаты работы каждого из алгоритмов для указанной СЛАУ.
- Измерь время, которое потребуется для выполнения *N* раз параллельного алгоритма решения заданной пользователем СЛАУ.
- Измерь время, которое потребуется для выполнения *N* раз обычного алгоритма решения заданной пользователем СЛАУ.
- Выведи на экран полученное в обоих случаях время.
- Для блокировки доступа к данным при параллельной реализации, используй мьютексы.

## Part 3. Алгоритм Винограда

Реализуй алгоритм Винограда умножения матриц без применения параллелизма, а также с использованием конвейерного и классического способов параллелизма:
- Программа должна быть разработана на языке C++ стандарта C++17.
- Код программы должен находиться в папке src.
- При написании кода придерживайся Google Style.
- Не используй устаревшие и выведенные из употребления конструкции языка и библиотечные функции.
- Добавь в существующий Makefile цель «winograd» для сборки программы.
- Должно быть выделено 4 стадии работы конвейера.
- У программы должен быть предусмотрен консольный интерфейс.
- Должно быть предусмотрено 2 способа ввода:
    - Пользователем задаются обе матриц для умножения;
    - Пользователем задаются размерности матриц, которые затем заполняются в программе случайным образом.
- Пользователем задается кол-во выполнений *N*.
- Выведи на экран результаты работы каждого из алгоритмов, а также сгенерированные матрицы.
- Измерь время, которое потребуется для выполнения *N* раз перемножения матриц без применения параллелизма.
- Измерь время, которое потребуется для выполнения *N* раз перемножения матриц с применением классического параллелизма при количестве потоков, равном 2, 4, 8, ..., 4 * (число логических процессоров компьютера).
- Измерь время, которое потребуется для выполнения *N* раз перемножения матриц с применением конвейерного параллелизма.
- Выведи на экран полученное в каждом случае время.
- Для блокировки доступа к данным при параллельной реализации используй мьютексы.


💡 [Нажми сюда](https://forms.yandex.ru/cloud/64181e44d0468826e3eb4a68/), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет нашей команде сделать твоё обучение лучше.
